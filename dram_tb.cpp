#include "Vmemory_controller.h"  // Generated by Verilator
#include "verilated.h"
#include "dram_model.h"
#include "verilated_vcd_c.h"
#include <iostream>

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);
    Vmemory_controller* mem_ctrl = new Vmemory_controller;

    // Enable waveform tracing
    Verilated::traceEverOn(true);
    VerilatedVcdC* trace = new VerilatedVcdC;
    mem_ctrl->trace(trace, 99);  // Trace depth
    trace->open("waveform.vcd"); // Open VCD file for GTKWave

    DRAMModel dram;

    // Simulation time counter
    vluint64_t main_time = 0;

    // --- Reset the controller ---
    mem_ctrl->rst = 1;
    mem_ctrl->wr_en = 0;
    mem_ctrl->rd_en = 0;
    mem_ctrl->clk = 0;
    // Assert reset for 10 cycles
    for (int i = 0; i < 10; i++) {
        // Toggle clock and dump waveform
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();
        main_time++;
    }
    mem_ctrl->rst = 0;
    std::cout << "Reset complete." << std::endl;

    // --- WRITE Transaction ---
    // Issue a write request to address 0xDEADBEEF with wdata = 69360420.
    std::cout << "\nStarting WRITE transaction..." << std::endl;
    mem_ctrl->wr_en = 1;
    mem_ctrl->request_valid = 1;
    mem_ctrl->rd_en = 0;
    mem_ctrl->addr = 0xDEADBEEF;
    mem_ctrl->wdata = 69360420;

    // Run until the controller asserts done (transaction complete)
    while (!((uint32_t)mem_ctrl->done)) {
        // Use the new DRAM interface (active-low signals are passed from mem_ctrl)
        dram.update(mem_ctrl->cs, mem_ctrl->ras, mem_ctrl->cas, mem_ctrl->we,
                    mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);

        // Toggle clock and update waveform
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();
        main_time++;
        if (main_time > 1000) {
            std::cerr << "Timeout during WRITE transaction." << std::endl;
            break;
        }
    }
    std::cout << "WRITE transaction reached DONE state." << std::endl;
    mem_ctrl->wr_en = 0; // End write transaction

    // Wait for the controller to return to IDLE (ctrllerstate == 0)
    std::cout << "Waiting for a return to an IDLE state." << std::endl;
    while (mem_ctrl->ctrllerstate != 0) {
        dram.update(mem_ctrl->cs, mem_ctrl->ras, mem_ctrl->cas, mem_ctrl->we,
                    mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);
                    
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();
        main_time++;
        if (main_time > 2000) {
            std::cerr << "Timeout waiting for IDLE after WRITE transaction." << std::endl;
            break;
        }
    }
    std::cout << "Controller returned to IDLE after WRITE transaction." << std::endl;

    // --- READ Transaction ---
    // Preload the DRAM memory so that the value 69360420 is available at 0xDEADBEEF.
    std::cout << "\nStarting READ transaction..." << std::endl;
    dram.set_memory(0xDEADBEEF, 69360420);

    // Issue a read request
    mem_ctrl->rd_en = 1;
    mem_ctrl->wr_en = 0;
    mem_ctrl->addr = 0xDEADBEEF;
    mem_ctrl->request_valid = 1;

    // Run until the controller asserts done
    while (!((uint32_t)mem_ctrl->done)) {
        dram.update(mem_ctrl->cs, mem_ctrl->ras, mem_ctrl->cas, mem_ctrl->we,
                    mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);

        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();
        mem_ctrl->request_valid = 0;
        main_time++;
        if (main_time > 3000) {
            std::cerr << "Timeout during READ transaction." << std::endl;
            break;
        }
    }
    std::cout << "READ transaction reached DONE state." << std::endl;

    // Verify that the controller output data matches the expected value.
    if (mem_ctrl->data == 69360420) {
        std::cout << "READ transaction returned correct data: " << mem_ctrl->data << std::endl;
    } else {
        std::cout << "ERROR: READ transaction returned incorrect data: " << mem_ctrl->data << std::endl;
    }
    mem_ctrl->rd_en = 0; // End read transaction

    // Wait for the controller to return to IDLE
    while (mem_ctrl->ctrllerstate != 0) {
        dram.update(mem_ctrl->cs, mem_ctrl->ras, mem_ctrl->cas, mem_ctrl->we,
                    mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);
                    
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();
        main_time++;
        if (main_time > 4000) {
            std::cerr << "Timeout waiting for IDLE after READ transaction." << std::endl;
            break;
        }
    }
    std::cout << "Controller returned to IDLE after READ transaction." << std::endl;
    std::cout << "\nTestbench completed successfully." << std::endl;

    // Final cleanup
    mem_ctrl->final();
    delete mem_ctrl;

    trace->close();
    delete trace;
    return 0;
}
