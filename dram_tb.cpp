#include "Vmemory_controller.h"  // Generated by Verilator
#include "verilated.h"
#include "dram_model.h"
#include "verilated_vcd_c.h"
#include <iostream>

// These macros should match the values used in the Verilog module
#define NO_COMMAND    0 
#define READ_COMMAND  1 
#define WRITE_COMMAND 2 

// Note: The state definitions in the Verilog module are:
//   IDLE = 0, READ_PENDING = 1, READ_ISSUE = 2, WRITE_ISSUE = 3, WRITE_PENDING = 4, DONE = 5
// However, the testbench only uses the "done" output and waits for the controller to return to IDLE.

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);
    Vmemory_controller* mem_ctrl = new Vmemory_controller;

    // Enable waveforms
    Verilated::traceEverOn(true);
    VerilatedVcdC* trace = new VerilatedVcdC;
    mem_ctrl->trace(trace, 99);  // Depth of signal tracing
    trace->open("waveform.vcd"); // Open VCD file for GTKWave

    DRAMModel dram;

    // Simulation time (cycle counter)
    vluint64_t main_time = 0;

    // --- Reset the controller ---
    mem_ctrl->rst = 1;
    mem_ctrl->wr_en = 0;
    mem_ctrl->rd_en = 0;
    mem_ctrl->clk = 0;
    // Let the reset be asserted for 10 cycles
    for (int i = 0; i < 10; i++) {

        // Toggle Clock and update waveforms
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();

        main_time++;
    }
    mem_ctrl->rst = 0;
    std::cout << "Reset complete." << std::endl;

    // --- WRITE Transaction ---
    // This test will "write" a value into memory.
    // We issue a write request to address 0xDEADBEEF with wdata = 69360420.
    std::cout << "\nStarting WRITE transaction..." << std::endl;
    mem_ctrl->wr_en = 1;
    mem_ctrl->request_valid = 1;
    mem_ctrl->rd_en = 0;
    mem_ctrl->addr = 0xDEADBEEF;
    mem_ctrl->wdata = 69360420;

    // Run until the controller asserts done (i.e. transaction complete)
    while (!((uint32_t)(mem_ctrl->done))) {
        // Update the DRAM model:
        // This call should update mem_ctrl->response_complete and mem_ctrl->response_data
        dram.update(mem_ctrl->request_command, mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);

        // Toggle Clock and update waveforms
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();

        main_time++;
        if (main_time > 1000) {
            std::cerr << "Timeout during WRITE transaction." << std::endl;
            break;
        }
    }
    std::cout << "WRITE transaction reached DONE state." << std::endl;
    // End the write transaction by de-asserting wr_en
    mem_ctrl->wr_en = 0;

    // Wait for the controller to return to the IDLE state (check via ctrllerstate)
    std::cout << "Waiting for a return to an IDLE state." << std::endl;
    while (mem_ctrl->ctrllerstate != 0) {  // assuming 0 is IDLE
        dram.update(mem_ctrl->request_command, mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);

        // Toggle Clock and update waveforms
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();

        main_time++;
        if (main_time > 2000) {
            std::cerr << "Timeout waiting for IDLE after WRITE transaction." << std::endl;
            break;
        }
    }
    std::cout << "Controller returned to IDLE after WRITE transaction." << std::endl;

    // --- READ Transaction ---
    // Now we perform a read to the same address. The DRAM model is updated to
    // supply the previously written value (69360420) at address 0xDEADBEEF.
    std::cout << "\nStarting READ transaction..." << std::endl;
    // Set up the DRAM model memory (assumes DRAMModel provides a set_memory() function)
    dram.set_memory(0xDEADBEEF, 69360420);

    // Issue a read request
    mem_ctrl->rd_en = 1;
    mem_ctrl->wr_en = 0;
    mem_ctrl->addr = 0xDEADBEEF;
    mem_ctrl->request_valid = 1;

    // Run until the controller asserts done
    while (!((uint32_t)(mem_ctrl->done))) {
        dram.update(mem_ctrl->request_command, mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);

        // Toggle Clock and update waveforms
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();

        mem_ctrl->request_valid = 0;
        main_time++;


        if (main_time > 3000) {
            std::cerr << "Timeout during READ transaction." << std::endl;
            break;
        }
    }
    std::cout << "READ transaction reached DONE state." << std::endl;

    // Check that the output data matches the value written earlier
    if (mem_ctrl->data == 69360420) {
        std::cout << "READ transaction returned correct data: " << mem_ctrl->data << std::endl;
    } else {
        std::cout << "ERROR: READ transaction returned incorrect data: " << mem_ctrl->data << std::endl;
    }
    // End the read transaction by de-asserting rd_en
    mem_ctrl->rd_en = 0;

    // Wait for the controller to return to IDLE
    while (mem_ctrl->ctrllerstate != 0) {  // 0 corresponds to IDLE
        dram.update(mem_ctrl->request_command, mem_ctrl->request_addr, mem_ctrl->request_data,
                    &mem_ctrl->response_complete, &mem_ctrl->response_data);

        // Toggle Clock and update waveforms
        mem_ctrl->clk = 1 - mem_ctrl->clk;
        trace->dump(main_time);
        mem_ctrl->eval();

        main_time++;
        if (main_time > 4000) {
            std::cerr << "Timeout waiting for IDLE after READ transaction." << std::endl;
            break;
        }
    }
    std::cout << "Controller returned to IDLE after READ transaction." << std::endl;
    std::cout << "\nTestbench completed successfully." << std::endl;


    // Final cleanup
    mem_ctrl->final();
    delete mem_ctrl;

    trace->close();
    delete trace;
    return 0;
}
